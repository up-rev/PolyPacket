/**
  *@file ${proto.fileName}.h
  *@brief generated code for ${proto.name} packet service
  *@author make_protocol.py
  *@date ${proto.genTime}
  *@hash ${proto.hash}
  */

#pragma once
/***********************************************************
        THIS FILE IS AUTOGENERATED. DO NOT MODIFY
***********************************************************/
extern "C"
{
  #include "Utilities/PolyPacket/poly_service.h"
}

#define ${proto.prefix.upper()}_SERVICE_HASH 0x${proto.hash}

/*******************************************************************************
  Enums
*******************************************************************************/
% for field in proto.fields:
% if field.isEnum:
/* Enums for ${field.name} field */
typedef enum{
  % for val in field.vals:
  ${proto.prefix.upper()+"_"+field.name.upper() + "_" + val.name.upper()},              /* ${val.desc} */
  % endfor
  ${proto.prefix.upper()+"_"+field.name.upper()}_MAX_LIMIT
} ${proto.prefix}_${field.name.lower()}_e;
%if proto.snippets:
//Switch Snippet
/*
switch(${field.name.lower()})
{
% for val in field.vals:
  case ${proto.prefix.upper()+"_"+field.name.upper() + "_" + val.name.upper()}:    // ${val.desc}
    break;
% endfor
  default:
    break;
}
*/
% endif

% endif
% endfor

/*******************************************************************************
  Bits/Flags
*******************************************************************************/
% for field in proto.fields:
% if field.isMask:
/* Flags for ${field.name} field */
typedef enum{
  % for idx,val in enumerate(field.vals):
  ${proto.prefix.upper()+"_"+field.name.upper() + "_" + val.name.upper()} = ${ field.valsFormat % (1 << idx)},    /* ${val.desc} */
  % endfor
  ${proto.prefix.upper()+"_"+field.name.upper()}_MAX_LIMIT
} ${proto.prefix}_${field.name.lower()}_e;

% endif
% endfor

/*******************************************************************************
  Global Descriptors
*******************************************************************************/
//Declare extern packet descriptors
% for packet in proto.packets:
extern poly_packet_desc_t* ${packet.globalName};
% endfor

% for struct in proto.structs:
extern poly_packet_desc_t* ${struct.globalName};
% endfor


//Declare extern field descriptors
% for field in proto.fields:
extern poly_field_desc_t* ${field.globalName};
% endfor


class ${proto.camelPrefix()}Packet {
  public:
    /**
      *@brief initializes a new {proto.prefix}_packet_t
      *@param desc ptr to packet descriptor to model packet from
      */
    ${proto.camelPrefix()}Packet(poly_packet_desc_t* desc);

    /**
      *@brief recrusively cleans packet and its contents if it still has ownership
      *@param packet packet to clean
      */
    ~${proto.camelPrefix()}Packet();


    /**
      *@brief converts packet to json
      *@param packet ptr to packet to convert
      *@param buf buffer to store string
      *@return length of string
      */
    int printJSON(packet,buf) poly_packet_print_json(&(packet)->mPacket, buf, false)

    /**
      *@brief parses packet from a buffer of data
      *@param packet ptr to packet to be built
      *@param buf buffer to parse
      *@return status of parse attempt
      */
     ${proto.prefix}_parse(packet,buf,len) poly_packet_parse_buffer(&(packet)->mPacket, buf, len)

    /**
      *@brief Copies all fields present in both packets from src to dst
      *@param dst ptr to packet to copy to
      *@param src ptr to packet to copy from
      */
    void copyFrom(${proto.prefix}Packet& src); // poly_packet_copy(&(dst)->mPacket,&(src)->mPacket )

    /**
      *@brief packs packet into a byte array
      *@param packet ptr to packet to be packed
      *@param buf buffer to store data
      *@return length of packed data
      */
    int pack(uint8_t* buf); // poly_packet_pack(&(packet)->mPacket, buf)

    /**
      *@brief gets the descriptor for the packet
      *@param packet ptr to packet to be checked
      */
    poly_packet_desc_t* desc() {return mPacket.mDesc;} // (&(packet)->mPacket.mDesc);

    /**
      *@brief checks to see if field is present in packet
      *@param packet ptr to packet to be packed
      *@param field ptr to field desc
      *@return true if field is present
      */
    bool hasField(poly_field_desc_t* field) {  return poly_packet_has(mPacket, field);}

    /*******************************************************************************
    Meta-Packet setters/Getters
    *******************************************************************************/
    % for field in proto.fields:
    %if field.isArray:
    void set${field.camel()}(const ${field.getParamType()} val);
    int get${field.camel()}(${field.getParamType()} val);
    % else:
    void set${field.camel()}(${field.getParamType()} val);
    ${field.getParamType()} get${field.camel()}();
    % endif
    % endfor

  private:
    poly_packet_t mPacket;
#ifdef POLY_PACKET_EASY_DEBUG
    % for field in proto.fields:
    ${field.getParamType()} m${field.camel()};
    % endfor
#endif

};

/*******************************************************************************
  Service Functions
*******************************************************************************/

class ${proto.camelPrefix()}Service {
  public:
    /**
      *@brief Constructor for protocol service
      *@param ifaces number of interfaces to use
      */
    ${proto.camelPrefix()}Service(int interfaceCount);

    /**
      *@brief Destructor for protocol service
      */
    ~${proto.camelPrefix()}Service();

    /**
      *@brief processes data in buffers
      */
    void process();

    /**
      *@brief registers a callback to let the service know how to send bytes for a given interface
      *@param iface index of interface to register with
      *@param txBytesCallBack a function pointer for the callback
      */
    void registerTxBytesCallback( int iface, poly_tx_bytes_callback txBytesCallBack);

    /**
      *@brief registers a callback to let the service know how to send entire packets
      *@param iface index of interface to register with
      *@param txPacketCallBack a function pointer for the callback
      */
    void registerTxPacketCallback( int iface, poly_tx_packet_callback txPacketCallBack);


    /**
      *@brief 'Feeds' bytes to service at given interface for processing
      *@param iface index of interface to send on
      *@param data data to be processed
      *@param number of bytes
      */
    void feed(int iface, uint8_t* data, int len);

    /**
      *@brief handles json message, and shortcuts the servicing proccess. used for http requests
      *@param req incoming json message string
      *@param resp response data
      *@param number of bytes
      */
    HandlerStatus_e handleJSON(const char* req,int len, char* resp);

    /**
      *@brief 'Feeds' json message to service
      *@param iface index of interface to send on
      *@param msg data to be processed
      *@param number of bytes
      */
    void feedJSON(int iface, const char* msg, int len);

    /**
      *@brief sends packet over given interface
      *@param packet packet to be sent
      *@param iface index of interface to send on
      */
    HandlerStatus_e send( int iface, ${proto.prefix}_packet_t* packet);

    /**
      *@brief enables/disables the auto acknowledgement function of the service
      *@param enable true enable auto acks, false disables them
      */
    void autoAck(bool enable);

    /**
      *@brief enables/disables the txReady of an interface
      *@param enable true enable auto acks, false disables them
      */
    void enableTx(int iface);
    void disableTx(int iface);


  private:

    /**
      *@brief registers the field/packet descriptors
      *@note needs to only be called once
      */
    static void buildDescriptors();

    /**
      *@brief handles packets and dispatches to handler
      *@param req incoming message
      *@param resp response to message
      *@param number of bytes
      */
    HandlerStatus_e dispatch(${proto.prefix}_packet_t* req, ${proto.prefix}_packet_t* resp);

    /*******************************************************************************
      Packet Handlers
    *******************************************************************************/
    % for packet in proto.packets:
    %if packet.hasResponse:
    /*@brief Handler for ${packet.name} packets */
    HandlerStatus_e ${packet.name}Handler(${proto.camelPrefix()}Packet& ${proto.prefix}Request, ${proto.camelPrefix()}Packet& ${proto.prefix}Response );
    %else:
    /*@brief Handler for ${packet.name} packets */
    HandlerStatus_e ${packet.name}Handler(${proto.camelPrefix()}Packet& ${proto.camelPrefix()}Request);
    %endif

    % endfor
    /*@brief Catch-All Handler for unhandled packets */
    HandlerStatus_e defaultHandler(${proto.camelPrefix()}Packet& ${proto.prefix}Request, ${proto.camelPrefix()}Packet& ${proto.prefix}Response );


};
